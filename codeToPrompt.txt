ini adalah kode sekarang:

langganan\admin.py:
from django.contrib import admin

# Register your models here.



langganan\apps.py:
from django.apps import AppConfig


class LanggananConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'langganan'



langganan\models.py:
from django.db import models
from django.contrib.auth.models import User

class Paket(models.Model):
    jenis = models.CharField(max_length=50, primary_key=True)
    harga = models.IntegerField()

class Transaction(models.Model):
    id = models.BigAutoField(primary_key=True)
    jenis_paket = models.ForeignKey(Paket, on_delete=models.CASCADE)
    email = models.ForeignKey(User, on_delete=models.CASCADE)
    timestamp_dimulai = models.DateTimeField()
    timestamp_berakhir = models.DateTimeField()
    metode_bayar = models.CharField(max_length=50)
    nominal = models.IntegerField()



langganan\tests.py:
from django.test import TestCase

# Create your tests here.



langganan\urls.py:
from django.urls import path
from . import views

app_name = 'langganan'

urlpatterns = [
    path('langganan_paket/', views.langganan_paket, name='langganan_paket'),
    path('riwayat_transaksi/', views.riwayat_transaksi, name='riwayat_transaksi'),
    path('pembayaran_paket/<str:jenis>/', views.pembayaran_paket, name='pembayaran_paket'),
]


langganan\views.py:
import uuid
from django.shortcuts import render, redirect
from django.urls import reverse
from django.utils import timezone
from .models import Paket, Transaction
from connector.query import query, get_session_info

def langganan_paket(request):
    ses_info = get_session_info(request)
    if not ses_info:
        return redirect('main:login')
    
    paket_list = query("SELECT * FROM PAKET")
    context = {'paket_list': paket_list}
    return render(request, 'langganan/langganan_paket.html', context)

def riwayat_transaksi(request):
    ses_info = get_session_info(request)
    if not ses_info:
        return redirect('main:login')
    
    email = ses_info['email']
    transaksi_list = query(f"""
        SELECT t.id, p.jenis, t.timestamp_dimulai, t.timestamp_berakhir, t.metode_bayar, t.nominal
        FROM TRANSACTION t
        JOIN PAKET p ON t.jenis_paket = p.jenis
        WHERE t.email = '{email}'
        ORDER BY t.timestamp_dimulai DESC
    """)
    
    context = {'transaksi_list': transaksi_list}
    return render(request, 'langganan/riwayat_transaksi.html', context)

def pembayaran_paket(request, jenis):
    ses_info = get_session_info(request)
    if not ses_info:
        return redirect('main:login')
    
    email = ses_info['email']
    
    if request.method == 'POST':
        metode_bayar = request.POST.get('metode_bayar')
        paket = query(f"SELECT * FROM PAKET WHERE jenis = '{jenis}'")
        if not paket:
            return redirect('langganan:langganan_paket')
        paket = paket[0]
        
        # Check for existing active subscription
        active_subscription = query(f"SELECT * FROM TRANSACTION WHERE email = '{email}' AND timestamp_berakhir > NOW()")
        if active_subscription:
            return render(request, 'langganan/langganan_paket.html', {'error': 'You already have an active subscription.'})
        
        # Create new transaction
        timestamp_dimulai = timezone.now()
        timestamp_berakhir = timestamp_dimulai + timezone.timedelta(days=int(paket['jenis'].split()[0]) * 30)
        transaction_id = str(uuid.uuid4())  # Generate a unique transaction ID
        
        query(f"""
            INSERT INTO TRANSACTION (id, jenis_paket, email, timestamp_dimulai, timestamp_berakhir, metode_bayar, nominal)
            VALUES ('{transaction_id}', '{jenis}', '{email}', '{timestamp_dimulai}', '{timestamp_berakhir}', '{metode_bayar}', {paket['harga']})
        """)
        
        # Update user to premium
        query(f"DELETE FROM NONPREMIUM WHERE email = '{email}'")
        query(f"INSERT INTO PREMIUM (email) VALUES ('{email}')")
        
        return redirect('langganan:riwayat_transaksi')
    else:
        paket = query(f"SELECT * FROM PAKET WHERE jenis = '{jenis}'")
        if not paket:
            return redirect('langganan:langganan_paket')
        paket = paket[0]
        context = {'paket': paket}
        return render(request, 'langganan/pembayaran_paket.html', context)


langganan\__init__.py:



marmut\asgi.py:
"""
ASGI config for marmut project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "marmut.settings")

application = get_asgi_application()



marmut\settings.py:
"""
Django settings for marmut project.

Generated by 'django-admin startproject' using Django 4.2.4.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.2/ref/settings/
"""

from pathlib import Path
import environ # Tambahkan kode berikut
import os # Tambahkan kode berikut
from django.core.management.utils import get_random_secret_key
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

env = environ.Env() # Tambahkan kode berikut

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = "django-insecure-5dgque*$6nl$6wj!p#7%6b=ot92+jm@f%!(*9-2tz!3=&n&+*w"

PRODUCTION = env.bool('PRODUCTION', False)

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ["*"]


# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "main",
    "playlist",
    "langganan",
    "song",
    "royalty_management",
]

LOGIN_URL = 'main:login'  # Change to your actual login URL
LOGIN_REDIRECT_URL = 'main:home'  # Change to the URL you want to redirect to after login
LOGOUT_REDIRECT_URL = 'main:login'  # Change to your actual logout redirect URL


AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend',
]

SESSION_ENGINE = 'django.contrib.sessions.backends.db'
SESSION_COOKIE_AGE = 1209600  # Two weeks
SESSION_SAVE_EVERY_REQUEST = True



MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = "marmut.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        'DIRS': [BASE_DIR / 'templates'],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "marmut.wsgi.application"


# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}

if PRODUCTION:
    DATABASES = {
        'default': env.db('DATABASE_URL')
    }
    DATABASES["default"]["ATOMIC_REQUESTS"] = True


# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",},
]


# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = "static/"

STATIC_ROOT = os.path.join(BASE_DIR, 'static')

# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"



marmut\urls.py:
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('main.urls')),
    path('playlist/', include('playlist.urls')),
    path('langganan/', include('langganan.urls', namespace='langganan')),
    path('song/', include('song.urls')),
    path('royalty_management/', include('royalty_management.urls')),
]



marmut\wsgi.py:
"""
WSGI config for marmut project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "marmut.settings")

application = get_wsgi_application()



marmut\__init__.py:



connector\query.py:
from collections import namedtuple
import psycopg2
from psycopg2 import Error
from psycopg2.extras import RealDictCursor
from django.http import HttpRequest  # for the 'request' parameter


try:
    connection = psycopg2.connect(user="postgres.tutzylpjrcjropovgoly",
                        password="eqRvUiBE4LZlukUp",
                        host="aws-0-ap-southeast-1.pooler.supabase.com",
                        port="5432",
                        database="postgres")

    # Create a cursor to perform database operations
    connection.autocommit = True
    cursor = connection.cursor()
except (Exception, Error) as error:
    print("Error while connecting to PostgreSQL", error)


def map_cursor(cursor):
    "Return all rows from a cursor as a namedtuple"
    desc = cursor.description
    nt_result = namedtuple("Result", [col[0] for col in desc])
    return [dict(row) for row in cursor.fetchall()]


def query(query_str: str):
    hasil = []
    with connection.cursor(cursor_factory=RealDictCursor) as cursor:
        cursor.execute("SET SEARCH_PATH TO PUBLIC")
        try:
            cursor.execute(query_str)

            if query_str.strip().upper().startswith("SELECT"):
                # Kalau ga error, return hasil SELECT
                hasil = map_cursor(cursor)
            else:
                # Kalau ga error, return jumlah row yang termodifikasi oleh INSERT, UPDATE, DELETE
                hasil = cursor.rowcount
                connection.commit()
        except Exception as e:
            # Ga tau error apa
            hasil = "error :\n" + str(e)

    return hasil

def get_session_info(request):
    session_id = request.COOKIES.get('session_id')
    if session_id:
        user = query(f"SELECT * FROM SESSIONS WHERE session_id = '{session_id}'")
        if user:
            return user[0]
    return None

def get_navbar_info(request: HttpRequest):
    session_info = get_session_info(request)

    if session_info:
        return {
            'is_guest': False,
            'is_user': not session_info['is_label'],
            'is_artist': session_info['is_artist'],
            'is_songwriter': session_info['is_songwriter']  ,
            'is_podcaster': session_info['is_podcaster'],
            'is_premium': session_info['is_premium'],
            'is_label': session_info['is_label'],
        }
    else:
        return {
            'is_guest': True,
            'is_user': False,
            'is_artist': False,
            'is_songwriter': False,
            'is_podcaster': False,
            'is_premium': False,
            'is_label': False,
        }


main\admin.py:
from django.contrib import admin

# Register your models here.



main\apps.py:
from django.apps import AppConfig


class MainConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "main"



main\forms.py:



main\lmao.py:
from collections import namedtuple
import psycopg2
from psycopg2 import Error
from psycopg2.extras import RealDictCursor



try:
    connection = psycopg2.connect(user="postgres.tutzylpjrcjropovgoly",
                        password="eqRvUiBE4LZlukUp",
                        host="aws-0-ap-southeast-1.pooler.supabase.com",
                        port="5432",
                        database="postgres")

    # Create a cursor to perform database operations
    connection.autocommit = True
    cursor = connection.cursor()
except (Exception, Error) as error:
    print("Error while connecting to PostgreSQL", error)


def map_cursor(cursor):
    "Return all rows from a cursor as a namedtuple"
    desc = cursor.description
    nt_result = namedtuple("Result", [col[0] for col in desc])
    return [dict(row) for row in cursor.fetchall()]


def query(query_str: str):
    hasil = []
    with connection.cursor(cursor_factory=RealDictCursor) as cursor:
        cursor.execute("SET SEARCH_PATH TO PUBLIC")
        try:
            cursor.execute(query_str)

            if query_str.strip().upper().startswith("SELECT"):
                # Kalau ga error, return hasil SELECT
                hasil = map_cursor(cursor)
            else:
                # Kalau ga error, return jumlah row yang termodifikasi oleh INSERT, UPDATE, DELETE
                hasil = cursor.rowcount
                connection.commit()
        except Exception as e:
            # Ga tau error apa
            hasil = "error :\n" + str(e)

    return hasil

email = "ganjar@pranowo.com"
id_konten = "f178a9c2-9054-4fe2-8972-77abc0998131"
# email_exists = query(f"""
#     SELECT * FROM 
#         (SELECT * FROM SONG WHERE id_konten = '{id_konten}') AS LAGU 
#         NATURAL JOIN 
#         (SELECT judul AS judul_lagu, tanggal_rilis, tahun, durasi FROM KONTEN WHERE id = '{id_konten}') AS CONTENT
#         JOIN
#         (SELECT id AS album_id, judul AS judul_album FROM ALBUM) AS ALBUM ON LAGU.id_album = ALBUM.album_id
#         JOIN 
#         (SELECT id AS artist_id, email_akun FROM ARTIST) AS ARTIST ON LAGU.id_artist = ARTIST.artist_id
#         JOIN
#         (SELECT email, nama FROM AKUN) AS AKUN ON ARTIST.email_akun = AKUN.email;
#     """)
# print(email_exists)
# songwriters = query(f"""
#     SELECT nama FROM AKUN WHERE email IN 
#         (SELECT email_akun FROM SONGWRITER WHERE id IN
#             (SELECT id_songwriter FROM SONGWRITER_WRITE_SONG WHERE id_song = '{id_konten}')
#         )
# """)

# print(songwriters)

# songwriters = [sw['nama'] for sw in songwriters]

# print(songwriters)

id_user_playlist = "05a104c1-e02b-4dff-bfc1-d52c92ba6ed2"
query_string = f"""
    SELECT *
    FROM USER_PLAYLIST up
    JOIN AKUN a ON up.email_pembuat = a.email
    WHERE up.id_user_playlist = '{id_user_playlist}';        
"""
playlist = query(query_string)[0]
# query_string = f"""
#     SELECT * FROM 
#     (SELECT * FROM SONG WHERE id_konten IN
#         (SELECT id_song FROM PLAYLIST_SONG WHERE id_playlist = '{playlist['id_playlist']}')) AS LAGU
#     JOIN
#     (SELECT id, judul AS judul_lagu, tanggal_rilis, tahun, durasi FROM KONTEN) AS CONTENT
#     ON LAGU.id_konten = CONTENT.id
#     JOIN
#     (SELECT id AS artist_id, email_akun FROM ARTIST) AS ARTIST ON LAGU.id_artist = ARTIST.artist_id
        
# """
# songs = query(query_string)
# for song in songs:
#     print(song)
#     print("=========")
# print(len(songs))
print(playlist)
print([1,2,3]+[4,5,6])


main\models.py:
from django.db import models
from django.contrib.auth.models import User

class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    birth_date = models.DateField()
    city = models.CharField(max_length=100)
    is_artist = models.BooleanField(default=False)
    is_songwriter = models.BooleanField(default=False)
    is_podcaster = models.BooleanField(default=False)

    def __str__(self):
        return self.user.username

class LabelProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    contact = models.CharField(max_length=100)

    def __str__(self):
        return self.user.username



main\tests.py:
from django.test import TestCase, Client

class mainTest(TestCase):
    def test_main_url_is_exist(self):
        response = Client().get('/main/')
        self.assertEqual(response.status_code, 200)

    def test_main_using_main_template(self):
        response = Client().get('/main/')
        self.assertTemplateUsed(response, 'main.html')


main\urls.py:
from django.urls import path
from main.views import show_main
from main.views import show_main,  play_song, play_user_playlist, register_user, register_label, home, login_and_register
from main.views import register , dashboard
from main.views import login_user
from main.views import logout_user
from main.views import search
from main.views import createpod
from .views import createpodepisode
from main.views import seechart
from main.views import daily
from main.views import weekly
from main.views import monthly
from main.views import yearly
from main.views import podetail
from main.views import download_song, add_song_to_playlist, user_play_song, shuffle_playlist

app_name = 'main'

urlpatterns = [
    path('', show_main, name='show_main'),
    path('register/', register, name='register'),
    path('login/', login_user, name='login'),
    path('logout/', logout_user, name='logout'),
    path('search/', search, name='search'),
    path('play-song/<str:id>/', play_song, name='play_song'),
    path('play-user-playlist/<str:id>/', play_user_playlist, name='play_user_playlist'),    
    path('createpod.html/', createpod, name='createpod'),
    path('createpod.html/createpod_episode.html/', createpodepisode, name='createpodepisode'),
    path('podetail.html/', podetail, name='podetail'),
    path('seechart.html/', seechart, name='seechart'),
    path('seechart.html/daily.html', daily, name='daily'),
    path('seechart.html/weekly.html', weekly, name='weekly'),
    path('seechart.html/monthly.html', monthly, name='monthly'),
    path('seechart.html/yearly.html', yearly, name='yearly'),
    path('register/user/', register_user, name='register_user'),
    path('register/label/', register_label, name='register_label'),
    path('home/', home, name='home'),
    path('login_and_register/', login_and_register, name='login_and_register'),
    path('dashboard/', dashboard, name='dashboard'),
    path('download-song/<str:id>/', download_song, name='download_song'),
    path('add-song-to-playlist/', add_song_to_playlist, name='add_song_to_playlist'),
    path('user-play-song/<str:id>/', user_play_song, name='user_play_song'),
    path('shuffle-playlist/<str:id>/', shuffle_playlist, name='shuffle_playlist')
]


main\views.py:
from django.shortcuts import render
from django.http import HttpResponseNotFound, HttpResponseRedirect
from django.urls import reverse
from django.http import HttpResponse
from django.core import serializers
from django.shortcuts import redirect
from django.contrib.auth.forms import UserCreationForm
from django.contrib import messages  
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.decorators import login_required
import datetime
from django.http import HttpResponseRedirect
from django.urls import reverse
from django.views.decorators.csrf import csrf_exempt

from django.shortcuts import render, redirect
from django.contrib.auth.models import User
from django.contrib.auth import login
from django.contrib.auth.hashers import make_password
from django.contrib.auth.models import User
from connector.query import query, get_session_info, get_navbar_info
import uuid
from django.http import HttpResponseRedirect
from django.urls import reverse


@csrf_exempt
def show_main(request):
    return redirect('main:login_and_register')

@csrf_exempt
def register_user(request):
    if request.method == 'POST':
        email = request.POST.get('email')
        password = request.POST.get('password')
        name = request.POST.get('name')
        gender = 1 if request.POST.get('gender') == "male" else 0
        birth_place = request.POST.get('birthplace')
        birth_date = request.POST.get('birthdate')
        city = request.POST.get('city')
        is_artist = 'True' == request.POST.get('is_artist')
        is_songwriter = 'True' == request.POST.get('is_songwriter')
        is_podcaster = 'True' == request.POST.get('is_podcaster')
        
        #CEK APAKAH EMAIL SUDAH TERDAFTAR
        is_verified = is_artist or is_songwriter or is_podcaster 
        pemilik_hak_cipta_id = str(uuid.uuid4())

        query_string = f"""
                INSERT INTO AKUN (email, password, nama, gender, tempat_lahir, tanggal_lahir, is_verified, kota_asal)
                VALUES ('{email}', '{password}', '{name}', {gender}, '{birth_place}', '{birth_date}', {is_verified}, '{city}');
            """
        
        if is_podcaster:
            query_string += f"""
                INSERT INTO PODCASTER (email)
                VALUES ('{email}');
            """
        
        if is_artist or is_songwriter:
            # Insert pemilik hak cipta
            rate_royalti = 0
            query_string += f"""
                INSERT INTO PEMILIK_HAK_CIPTA (id, rate_royalti)
                VALUES ('{pemilik_hak_cipta_id}', {rate_royalti});
            """

        if is_artist:
            artist_uuid = str(uuid.uuid4())
            
            # Insert artist
            query_string += f"""
                INSERT INTO ARTIST (id, email_akun, id_pemilik_hak_cipta)
                VALUES ('{artist_uuid}', '{email}', '{pemilik_hak_cipta_id}');
            """
            
        if is_songwriter:
            songwriter_uuid = str(uuid.uuid4())
            
            
            query_string += f"""
                INSERT INTO SONGWRITER (id, email_akun, id_pemilik_hak_cipta)
                VALUES ('{songwriter_uuid}', '{email}', '{pemilik_hak_cipta_id}');
            """

        res = query(query_string)
        print("cok", res)
        
        if "error" in str(res):
            messages.error(request, 'An error occurred while registering your account. Please try again later.')
            print(res)
        else:
            messages.success(request, 'Registration successful!')
            return redirect('main:login')  
    context = {
        'navbar' : get_navbar_info(request)
    }
    return render(request, 'register_user.html', context)

@csrf_exempt
def register_label(request):
    if request.method == 'POST':
        email = request.POST.get('email')
        password = request.POST.get('password')
        contact = request.POST.get('contact')
        name = request.POST.get('name')
        label_uuid = str(uuid.uuid4())
        pemilik_hak_cipta_id = str(uuid.uuid4())
        
        #CEK APAKAH EMAIL SUDAH TERDAFTAR
        

        # Insert pemilik hak cipta
        rate_royalti = 0
        query_string = f"""
            INSERT INTO PEMILIK_HAK_CIPTA (id, rate_royalti)
            VALUES ('{pemilik_hak_cipta_id}', {rate_royalti});
        """

        # Insert label
        query_string += f"""
                INSERT INTO label (id, nama, email, password, kontak, id_pemilik_hak_cipta) VALUES
                ('{label_uuid}', '{name}', '{email}', '{password}', '{contact}', '{pemilik_hak_cipta_id}');
        """

        res = query(query_string)

        if "error" in str(res):
            if("Email sudah terdaftar" in str(res)):
                messages.error(request, 'Email is already registered!')
            else:
                messages.error(request, 'An error occurred while registering your account. Please try again later.')
            print(res)
        else:
            messages.success(request, 'Registration successful!')
            return redirect('main:login')  # Redirect to a home or profile page
    context = {
        'navbar' : get_navbar_info(request)
    }
    return render(request, 'register_label.html', context)
@csrf_exempt
def register(request):
    # Simply render the choice page without any logic for POST methods
    context = {
        'navbar' : get_navbar_info(request)
    }
    return render(request, 'register.html', context)
@csrf_exempt
def login_and_register(request):
    context = {
        'navbar' : get_navbar_info(request)
    }
    return render(request, 'login_and_register.html', context)
@csrf_exempt
def login_user(request):
    if request.method == 'POST':
        email = request.POST.get('email')
        password = request.POST.get('password')
        user = query(f"SELECT email FROM AKUN WHERE email = '{email}' AND password = '{password}' UNION SELECT email FROM LABEL WHERE email = '{email}' AND password = '{password}'")
        print(user)
        if len(user) == 0:
            messages.error(request, 'Invalid email or password!')
        else:
            is_artist = len(query(f"SELECT * FROM ARTIST WHERE email_akun = '{email}'")) != 0
            is_songwriter = len(query(f"SELECT * FROM SONGWRITER WHERE email_akun = '{email}'")) != 0
            is_podcaster = len(query(f"SELECT * FROM PODCASTER WHERE email = '{email}'")) != 0
            is_premium = len(query(f"SELECT * FROM PREMIUM WHERE email = '{email}'")) != 0
            is_label = len(query(f"SELECT * FROM LABEL WHERE email = '{email}'")) != 0

            session_id = str(uuid.uuid4())
            temp = query(f"""INSERT INTO SESSIONS (session_id, email, is_label, is_premium, is_artist, is_songwriter, is_podcaster) 
                  VALUES ('{session_id}', '{email}' , {is_label}, {is_premium}, {is_artist}, {is_songwriter}, {is_podcaster})
                """)
            

            response = redirect('main:dashboard')
            response.set_cookie('session_id', session_id)
            return response
    context = {
        'navbar' : get_navbar_info(request)
    }
    return render(request, 'login.html', context)
@csrf_exempt
def logout_user(request):
    session_id = request.COOKIES.get('session_id')
    if session_id:
        query(f"DELETE FROM SESSIONS WHERE session_id = '{session_id}'")  # Delete session from database


    response = HttpResponseRedirect(reverse('main:login'))
    response.delete_cookie('session_id')  # Delete session_id cookie
    return response

@csrf_exempt
def play_song(request, id):
    user = get_session_info(request)
    if not user:
        return redirect('main:login')
    id_konten = id
    query_string = f"""
    SELECT * FROM 
        (SELECT * FROM SONG WHERE id_konten = '{id_konten}') AS LAGU 
        NATURAL JOIN 
        (SELECT judul AS judul_lagu, tanggal_rilis, tahun, durasi FROM KONTEN WHERE id = '{id_konten}') AS CONTENT
        JOIN
        (SELECT id AS album_id, judul AS judul_album FROM ALBUM) AS ALBUM ON LAGU.id_album = ALBUM.album_id
        JOIN 
        (SELECT id AS artist_id, email_akun FROM ARTIST) AS ARTIST ON LAGU.id_artist = ARTIST.artist_id
        JOIN
        (SELECT email, nama FROM AKUN) AS AKUN ON ARTIST.email_akun = AKUN.email;
    """
    
    genre = query(f"SELECT genre FROM GENRE WHERE id_konten = '{id_konten}'")
    genre = [g['genre'] for g in genre]

    songwriters = query(f"""
        SELECT nama FROM AKUN WHERE email IN 
            (SELECT email_akun FROM SONGWRITER WHERE id IN
                (SELECT id_songwriter FROM SONGWRITER_WRITE_SONG WHERE id_song = '{id_konten}')
            )
    """)

    songwriters = [sw['nama'] for sw in songwriters]

    user_playlist = query(f"SELECT * FROM USER_PLAYLIST WHERE email_pembuat = '{user['email']}'")
    user_playlist = [{'id': p['id_user_playlist'], 'title': p['judul']} for p in user_playlist]

    is_downloaded = query(f"SELECT * FROM DOWNLOADED_SONG WHERE id_song = '{id_konten}' AND email_downloader = '{user['email']}'")
    is_downloaded = len(is_downloaded) > 0

    konten = query(query_string)[0]    

    song_data = {
        'id': konten['id_konten'],
        'title': konten['judul_lagu'],
        'genres': genre,
        'artist': konten['nama'],
        'songwriters': songwriters,
        'duration': konten['durasi'],  
        'release_date': konten['tanggal_rilis'],
        'year': konten['tahun'],
        'album': konten['judul_album'],
        'total_plays': konten['total_play'],  
        'total_downloads': konten['total_download'],  
        'user_playlists': user_playlist,
        'is_downloaded': is_downloaded,
    }
    context = {
        'song': song_data,
        'user': request.user,
        'user_is_premium': user['is_premium'],
        'navbar' : get_navbar_info(request),
    }
    return render(request, 'play_song.html', context)
@csrf_exempt
def download_song(request, id):
    user = get_session_info(request)
    if not user:
        return redirect('main:login')
    email = user['email']
    id_konten = id
    query_string = f"""
        INSERT INTO DOWNLOADED_SONG (id_song, email_downloader) VALUES ('{id_konten}', '{email}');
    """
    res = query(query_string)
    if "error" in str(res):
        return HttpResponseNotFound("Download Failed")
    else:
        return HttpResponse("Song downloaded successfully!")
@csrf_exempt
def add_song_to_playlist(request):
    id_song = request.POST.get('id_song')
    id_playlist = request.POST.get('id_playlist')

    query_string = f"""
        INSERT INTO PLAYLIST_SONG (id_playlist, id_song) VALUES ((SELECT id_playlist FROM USER_PLAYLIST WHERE id_user_playlist = '{id_playlist}'), '{id_song}');
    """
    res = query(query_string)
    print(res)
    if "error" in str(res):
        return HttpResponseNotFound("Failed to add song to playlist")
    else:
        return redirect('main:play_user_playlist', id=id_playlist)
@csrf_exempt
def user_play_song(request, id):
    user = get_session_info(request)
    if not user:
        return redirect('main:login')
    id_konten = id
    waktu = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    query_string = f"""
        INSERT INTO AKUN_PLAY_SONG (email_pemain, id_song, waktu) VALUES ('{user['email']}', '{id_konten}', '{waktu}');
    """
    res = query(query_string)
    print(res)
    if "error" in str(res):
        return HttpResponseNotFound("Failed to play song")
    else:
        return HttpResponse("Song played successfully!")

@csrf_exempt
def play_user_playlist(request, id):
    user = get_session_info(request)
    if not user:
        return redirect('main:login')
    id_user_playlist = id
    query_string = f"""
        SELECT *
        FROM USER_PLAYLIST up
        JOIN AKUN a ON up.email_pembuat = a.email
        WHERE up.id_user_playlist = '{id_user_playlist}';        
    """
    playlist = query(query_string)[0]
    query_string = f"""
        SELECT * FROM 
        (SELECT * FROM SONG WHERE id_konten IN 
            (SELECT id_song FROM PLAYLIST_SONG WHERE id_playlist = '{playlist['id_playlist']}')) AS LAGU
        JOIN
        (SELECT id, judul AS judul_lagu, tanggal_rilis, tahun, durasi FROM KONTEN) AS CONTENT
        ON LAGU.id_konten = CONTENT.id
        JOIN
        (SELECT id AS artist_id, email_akun FROM ARTIST) AS ARTIST ON LAGU.id_artist = ARTIST.artist_id
        JOIN
        (SELECT email, nama FROM AKUN) AS AKUN ON ARTIST.email_akun = AKUN.email;
    """
    songs = query(query_string)
    
    songs_data = []
    total_hours = playlist['total_durasi'] // 60
    total_minutes = playlist['total_durasi'] % 60
    for song in songs:
        songs_data.append({
            'title': song['judul_lagu'],
            'artist': song['nama'],
            'duration': song['durasi'],
            'id_song': song['id_konten']
        })
    
    playlist_data = {
        'id': playlist['id_user_playlist'],
        'title': playlist['judul'],
        'creator': playlist['nama'],
        'songs': songs_data,
        'total_duration_hours': total_hours,
        'total_duration_minutes': total_minutes,
        'created_date': playlist['tanggal_dibuat'],
        'description': playlist['deskripsi']
    }
    print(playlist_data)
    context = {
        'playlist': playlist_data,
        'navbar' : get_navbar_info(request),
    }
    
    return render(request, 'play_user_playlist.html', context)

@csrf_exempt
def shuffle_playlist(request, id):
    id_user_playlist = id

    user = get_session_info(request)
    if not user:
        return redirect('main:login')
    player = user['email']
    query_string = f"""
        
        INSERT INTO AKUN_PLAY_USER_PLAYLIST (email_pemain, id_user_playlist, email_pembuat, waktu)
        SELECT '{player}', id_user_playlist, email_pembuat, current_timestamp
        FROM USER_PLAYLIST
        WHERE id_user_playlist = '{id_user_playlist}';

        
        INSERT INTO AKUN_PLAY_SONG (email_pemain, id_song, waktu)
        SELECT 
            '{player}' AS email_pemain, 
            ps.id_song AS id_song, 
            current_timestamp AS waktu
        FROM 
            PLAYLIST_SONG ps
        JOIN 
            USER_PLAYLIST up ON ps.id_playlist = up.id_playlist
        WHERE 
            up.id_user_playlist = '{id_user_playlist}';
    """
    res = query(query_string)

    if "error" in str(res):
        return HttpResponseNotFound("Failed to shuffle playlist")
    else:
        return HttpResponse("Playlist shuffled successfully!")


def search(request):
    query_str = request.GET.get('query')
    pass
#     query = request.GET.get('query')
    
    if query_str:
        songs = query(f"""
            SELECT k.id, k.judul AS title, string_agg(distinct g.genre, ', ') AS genre, ak.nama AS artist_name
            FROM KONTEN k
            JOIN SONG s ON k.id = s.id_konten
            JOIN GENRE g ON k.id = g.id_konten
            JOIN ARTIST a ON s.id_artist = a.id
            JOIN AKUN ak ON a.email_akun = ak.email
            WHERE k.judul ILIKE '%{query_str}%'
            GROUP BY k.id, k.judul, ak.nama
        """)
        
        user_playlists = query(f"""
            SELECT up.id_user_playlist, up.judul AS title, up.email_pembuat AS creator_email, ak.nama AS creator_name
            FROM USER_PLAYLIST up
            JOIN AKUN ak ON up.email_pembuat = ak.email
            WHERE up.judul ILIKE '%{query_str}%'
        """)
#     if query:
#         songs = Song.objects.filter(title__icontains=query)
#         podcasts = podcast.objects.filter(title__icontains=query)
#         user_playlists = UserPlaylist.objects.filter(title__icontains=query)
        
        results = []
        for song in songs:
            results.append({
                'type': 'SONG',
                'title': song['title'],
                'genre': song['genre'],
                'by': song['artist_name'],
                'url': reverse('song_detail', args=[song['id']])
            })
        for playlist in user_playlists:
            results.append({
                'type': 'USER PLAYLIST',
                'title': playlist['title'],
                'by': playlist['creator_name'],
                'url': reverse('playlist_detail', args=[playlist['id_user_playlist'], playlist['creator_email']])
            })
    else:
        results = []
#         results = []
#         for song in songs:
#             results.append({
#                 'type': 'SONG',
#                 'title': song.title,
#                 'by': song.artist,
#                 'url': reverse('song_detail', args=[song.id])
#             })
#         for podcast in podcasts:
#             results.append({
#                 'type': 'PODCAST',
#                 'title': podcast.title,
#                 'by': podcast.podcaster,
#                 'url': reverse('podcast_detail', args=[podcast.id])
#             })
#         for playlist in user_playlists:
#             results.append({
#                 'type': 'USER PLAYLIST',
#                 'title': playlist.title,
#                 'by': playlist.user.username,
#                 'url': reverse('playlist_detail', args=[playlist.id])
#             })
#     else:
#         results = []
    
    context = {
        'query': query_str,
        'results': results
    }
    return render(request, 'search_results.html', context)
#     context = {
#         'query': query,
#         'results': results
#     }
#     return render(request, 'main/search_results.html', context)



def createpod(request):
    # Logika untuk menampilkan halaman createpod.html
    return render(request, 'createpod.html')


def createpodepisode(request):
    # Logika untuk menampilkan halaman createpod.html
    return render(request, 'createpod_episode.html')

def seechart(request):
    # Logika untuk menampilkan halaman createpod.html
    return render(request, 'seechart.html')

def daily(request):
    return render(request, 'daily.html')

def weekly(request):
    return render(request, 'weekly.html')

def monthly(request):
    return render(request, 'monthly.html')

def yearly(request):
    return render(request, 'yearly.html')


def podetail(request):
    return render(request, "podcastdetail.html")

@csrf_exempt
def home(request):
    #redirect to login and register
    return redirect('main:login_and_register')

@csrf_exempt
def dashboard(request):
    # Get user from session
    ses_info = get_session_info(request)
    email = ses_info['email']
    if not email:
        return redirect('main:login')
    
    user = query(f"SELECT * FROM AKUN WHERE email = '{email}'")[0]
    if ses_info['is_label']:
        user = query(f"SELECT * FROM LABEL WHERE email = '{email}'")[0]
    
    roles = []
    if ses_info['is_label']:
        roles.append("Label")
    if ses_info['is_artist']:
        roles.append("Artist")
    if ses_info['is_songwriter']:
        roles.append("Songwriter")
    if ses_info['is_podcaster']:
        roles.append("Podcaster")
    roles.append("Pengguna")
    role_str = ", ".join(roles)

    if ses_info['is_label']:
        album_list = query(f"SELECT * FROM ALBUM JOIN LABEL ON ALBUM.id_label = LABEL.id WHERE LABEL.email = '{email}'")
        album_list = [{'title': album['judul'], 'release_date': album['tanggal_rilis']} for album in album_list]
    else:
        album_list = []

    if ses_info['is_podcaster']:
        podcasts = query(f"SELECT * FROM PODCAST JOIN KONTEN ON PODCAST.id_konten = KONTEN.id WHERE PODCAST.email_podcaster = '{email}'")
        podcasts = [{'title': podcast['judul'], 'release_date': podcast['tanggal_rilis'], 'durasi': podcast['durasi']} for podcast in podcasts]
    else:
        podcasts = []
    
    if ses_info['is_artist']:
        songs_artist = query(f"SELECT judul, tanggal_rilis, durasi  FROM SONG JOIN KONTEN ON SONG.id_konten = KONTEN.id JOIN ARTIST ON ARTIST.id = SONG.id_artist WHERE ARTIST.email_akun = '{email}'")
        print(songs_artist)
        songs_artist = [{'title': song['judul'], 'release_date': song['tanggal_rilis'], 'durasi': song['durasi']} for song in songs_artist]
    else:
        songs_artist = []
    
    if ses_info['is_songwriter']:
        songs_songwriter = query(f"SELECT * FROM KONTEN WHERE KONTEN.id IN (SELECT id_song FROM SONGWRITER_WRITE_SONG WHERE SONGWRITER_WRITE_SONG.id_songwriter = (SELECT id FROM SONGWRITER WHERE email_akun = '{email}'))")
        songs_songwriter = [{'title': song['judul'], 'release_date': song['tanggal_rilis'], 'durasi': song['durasi']} for song in songs_songwriter]
    else:
        songs_songwriter = []
    
    songs = songs_artist + songs_songwriter

    playlists = query(f"""
        SELECT * FROM USER_PLAYLIST up
        JOIN AKUN a ON up.email_pembuat = a.email
        WHERE up.email_pembuat = '{email}';
    """)
    print(playlists)
    playlists = [{'title': playlist['judul'], 'created_at': playlist['tanggal_dibuat'], 'song_count': playlist['jumlah_lagu'], 'total_duration': playlist['total_durasi']} for playlist in playlists]

    user = {
        'name': user['nama'],
        'email': user['email'],
        'city': user['kota_asal'],
        'gender': user['gender'],
        'birth_place': user['tempat_lahir'],
        'birth_date': user['tanggal_lahir'],
        'role': role_str,
        'playlists': playlists,
        'songs': songs,
        'podcasts': podcasts,
        'albums': album_list,
    }

    context = {
        'user': user,
        'user_type': 'user',
        'navbar' : get_navbar_info(request),
    }
    return render(request, 'dashboard.html', context)


main\__init__.py:



